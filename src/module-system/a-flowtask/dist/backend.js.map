{"version":3,"sources":["webpack://egg-born-module-a-flowtask/./backend/src/aops.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/bean.flowTask.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/flow.node.activityUserTask.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/flow.node.endEventAtom.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/flow.node.startEventAtom.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/io.message.workflow.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/local.context.task.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/local.flow.task.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/local.procedure.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/stats.taskClaimings.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/stats.taskHandlings.js","webpack://egg-born-module-a-flowtask/./backend/src/bean/version.manager.js","webpack://egg-born-module-a-flowtask/./backend/src/beans.js","webpack://egg-born-module-a-flowtask/./backend/src/common/flowNodeActivityUserTaskBase.js","webpack://egg-born-module-a-flowtask/./backend/src/common/utils.js","webpack://egg-born-module-a-flowtask/./backend/src/common/vars.js","webpack://egg-born-module-a-flowtask/./backend/src/config/config.js","webpack://egg-born-module-a-flowtask/./backend/src/config/errors.js","webpack://egg-born-module-a-flowtask/./backend/src/config/flow/defaults.js","webpack://egg-born-module-a-flowtask/./backend/src/config/flow/nodes.js","webpack://egg-born-module-a-flowtask/./backend/src/config/locale/en-us.js","webpack://egg-born-module-a-flowtask/./backend/src/config/locale/zh-cn.js","webpack://egg-born-module-a-flowtask/./backend/src/config/locales.js","webpack://egg-born-module-a-flowtask/./backend/src/config/validation/schema/activityUserTask.js","webpack://egg-born-module-a-flowtask/./backend/src/config/validation/schema/startEventAtom.js","webpack://egg-born-module-a-flowtask/./backend/src/config/validation/schemas.js","webpack://egg-born-module-a-flowtask/./backend/src/controller/flow.js","webpack://egg-born-module-a-flowtask/./backend/src/controller/flowTask.js","webpack://egg-born-module-a-flowtask/./backend/src/controllers.js","webpack://egg-born-module-a-flowtask/./backend/src/main.js","webpack://egg-born-module-a-flowtask/./backend/src/meta.js","webpack://egg-born-module-a-flowtask/./backend/src/model/flowNodeStartEventAtomCondition.js","webpack://egg-born-module-a-flowtask/./backend/src/model/flowTask.js","webpack://egg-born-module-a-flowtask/./backend/src/model/flowTaskHistory.js","webpack://egg-born-module-a-flowtask/./backend/src/models.js","webpack://egg-born-module-a-flowtask/./backend/src/routes.js","webpack://egg-born-module-a-flowtask/./backend/src/service/flow.js","webpack://egg-born-module-a-flowtask/./backend/src/service/flowTask.js","webpack://egg-born-module-a-flowtask/./backend/src/services.js","webpack://egg-born-module-a-flowtask/external \"require3\"","webpack://egg-born-module-a-flowtask/webpack/bootstrap","webpack://egg-born-module-a-flowtask/webpack/startup"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;;;;ACHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC,gCAAgC,0BAA0B;AAC1D;;AAEA,kBAAkB,6CAA6C;AAC/D,sCAAsC,kCAAkC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA,yDAAyD,mBAAmB;AAC5E;AACA;;AAEA,oBAAoB,qCAAqC;AACzD;AACA,yDAAyD,mBAAmB;AAC5E,oCAAoC,mBAAmB;AACvD;;AAEA,qBAAqB,mBAAmB;AACxC;AACA,yDAAyD,mBAAmB;AAC5E;AACA;;AAEA,iCAAiC,2BAA2B;AAC5D;AACA,yDAAyD,mBAAmB;AAC5E,iDAAiD,SAAS;AAC1D;;AAEA,kBAAkB,mBAAmB;AACrC;AACA,yDAAyD,mBAAmB;AAC5E;AACA;;AAEA,sBAAsB,2BAA2B;AACjD;AACA,yDAAyD,mBAAmB;AAC5E,sCAAsC,SAAS;AAC/C;;AAEA,mBAAmB,mBAAmB;AACtC;AACA,yDAAyD,mBAAmB;AAC5E;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA,yDAAyD,kCAAkC;AAC3F;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA,yDAAyD,mCAAmC;AAC5F;AACA;;AAEA,8BAA8B,aAAa;AAC3C;AACA,sEAAsE,aAAa;AACnF;AACA,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA,OAAO;AACP;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA,OAAO;AACP;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;;AAEA,qCAAqC,eAAe;AACpD;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;;AAEA,uCAAuC,wBAAwB;AAC/D;AACA,+CAA+C,mDAAmD;AAClG;;AAEA,iCAAiC,0DAA0D;AAC3F;AACA;AACA;AACA;AACA;AACA,kEAAkE,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,iDAAiD,eAAe;AAChE;AACA,iCAAiC,0CAA0C;AAC3E;AACA;;AAEA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA,SAAS;AACT,OAAO;AACP;;AAEA,0CAA0C,eAAe;AACzD,gCAAgC,eAAe;AAC/C;;AAEA,iBAAiB,WAAW,yCAAyC,qCAAqC;AAC1G;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC;AAClC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE,OAAO;AACP,wDAAwD,aAAa;AACrE;AACA;AACA;AACA,sEAAsE,2CAA2C;AACjH;AACA,8CAA8C,eAAe;AAC7D,wBAAwB,0BAA0B;AAClD;AACA;;AAEA,0BAA0B,eAAe;AACzC,wCAAwC,wBAAwB;AAChE;AACA,OAAO;AACP;AACA;;AAEA,+BAA+B,qCAAqC;AACpE,8CAA8C,eAAe;AAC7D,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;;;;;;;AC5SA,qCAAqC,mBAAO,CAAC,GAA2C;;AAExF;AACA;AACA;;AAEA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;ACvBA,qCAAqC,mBAAO,CAAC,GAA2C;;AAExF;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA,kCAAkC,kBAAkB;AACpD,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS,EAAE;AACX;AACA;AACA,oBAAoB;AACpB;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,SAAS;AACT;AACA;;AAEA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA,4DAA4D,UAAU,GAAG,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,2BAA2B;AACpF;AACA;AACA;AACA;;AAEA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA,sDAAsD,kCAAkC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,wCAAwC,oBAAoB;AAC5D;;AAEA;;AAEA;AACA;;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;;AAEA;;AAEA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;AC9BA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA,eAAe,mBAAO,CAAC,GAAmB;AAC1C,gBAAgB,mBAAO,CAAC,GAAoB;;AAE5C;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,8CAA8C,wBAAwB;AACtE;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA,qDAAqD,uBAAuB;AAC5E;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA,+BAA+B,yCAAyC;AACxE;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oCAAoC;AACtF,sDAAsD,qBAAqB;AAC3E,yBAAyB,6CAA6C,KAAK,8EAA8E;AACzJ,sDAAsD,qBAAqB,cAAc,WAAW;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA,mEAAmE,iBAAiB;AACpF;AACA,+EAA+E,aAAa;AAC5F;AACA;AACA;AACA;AACA,8CAA8C,uCAAuC;AACrF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kCAAkC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kCAAkC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD,SAAS;AACT;AACA;AACA;AACA;;AAEA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,qBAAqB,wBAAwB,0BAA0B,WAAW;AAClF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA,wBAAwB,SAAS,QAAQ,WAAW,EAAE,EAAE;AACxD,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,gEAAgE,kCAAkC;AAClG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kCAAkC;AAClG;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;;AAEA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,SAAS,EAAE;AAC1D;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,sCAAsC,kDAAkD;AACxF;AACA,wCAAwC,0CAA0C;AAClF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA,gEAAgE,kCAAkC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,kBAAkB,sBAAsB;AACxC;AACA,OAAO;AACP;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,kEAAkE,kCAAkC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,eAAe;AAC1D;;AAEA;AACA,2CAA2C,gBAAgB;AAC3D;;AAEA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,oCAAoC,eAAe;AACnD;;AAEA;AACA,oCAAoC,gBAAgB;AACpD;;AAEA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA,gEAAgE,kCAAkC;AAClG;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA,qCAAqC,6CAA6C;AAClF,yGAAyG,qBAAqB;AAC9H;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC1sBA;AACA;;AAEA,iBAAiB,sDAAsD;AACvE;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,6CAA6C;AACjF;AACA,kCAAkC,6CAA6C;AAC/E;;AAEA,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,MAAM;AACtC;AACA;;AAEA;AACA;AACA,8CAA8C,UAAU;AACxD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA,qCAAqC;AACrC,eAAe;AACf;;AAEA,YAAY;AACZ,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,MAAM;AACtC;AACA;;AAEA;AACA;AACA,8CAA8C,UAAU;AACxD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA,qCAAqC;AACrC,eAAe;AACf;;AAEA,YAAY;AACZ,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;ACjJA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;;;;;;;AClBA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;;;;;;;AClBA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;;ACrFA,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,+BAA+B,mBAAO,CAAC,GAAoC;AAC3E,6BAA6B,mBAAO,CAAC,GAAkC;AACvE,iCAAiC,mBAAO,CAAC,GAAsC;AAC/E,yBAAyB,mBAAO,CAAC,GAA8B;AAC/D,sBAAsB,mBAAO,CAAC,GAA2B;AACzD,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,qBAAqB,mBAAO,CAAC,GAAyB;AACtD,2BAA2B,mBAAO,CAAC,GAA+B;AAClE,2BAA2B,mBAAO,CAAC,GAA+B;AAClE,0BAA0B,mBAAO,CAAC,GAA+B;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;ACnEA,iBAAiB,mBAAO,CAAC,GAAU;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,gDAAgD,UAAU;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C,gCAAgC;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,eAAe;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,kCAAkC;AAC/E;;AAEA,6BAA6B,UAAU;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C,gCAAgC;AAC3E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACrIA,mBAAmB,wBAAwB;AAC3C;;AAEA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;;AAEA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;;;;;;;ACrBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;ACrDA,iBAAiB,mBAAO,CAAC,GAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA,WAAW,mBAAO,CAAC,GAAmB;AACtC,WAAW,mBAAO,CAAC,EAAmB;AACtC;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;;;;;;;AC3BA,uBAAuB,mBAAO,CAAC,GAA4B;AAC3D,yBAAyB,mBAAO,CAAC,GAA8B;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;ACdA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;;ACvGA,aAAa,mBAAO,CAAC,GAAsB;AAC3C,iBAAiB,mBAAO,CAAC,GAA0B;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA,eAAe,mBAAO,CAAC,EAAoB;AAC3C,gBAAgB,mBAAO,CAAC,EAAqB;AAC7C,eAAe,mBAAO,CAAC,GAAoB;;AAE3C;;AAEA;AACA,eAAe,mBAAO,CAAC,GAAW;AAClC;AACA,gBAAgB,mBAAO,CAAC,GAAY;AACpC;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,sBAAsB,mBAAO,CAAC,EAAkB;AAChD;AACA,mBAAmB,mBAAO,CAAC,GAAe;AAC1C;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,eAAe,mBAAO,CAAC,GAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA;AACA,kBAAkB,mBAAO,CAAC,GAAgC;AAC1D,oBAAoB,mBAAO,CAAC,GAAwB;AACpD;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA,kBAAkB,sDAAsD,uBAAuB,EAAE;AACjG;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA,kBAAkB,+BAA+B,uBAAuB,EAAE;AAC1E;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA,kBAAkB,sCAAsC,wBAAwB,EAAE;AAClF;AACA;AACA;AACA;;;;;;;;ACPA,wCAAwC,mBAAO,CAAC,GAA4C;AAC5F,iBAAiB,mBAAO,CAAC,GAAqB;AAC9C,wBAAwB,mBAAO,CAAC,GAA4B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;AACA;AACA;AACA,KAAK,wDAAwD;AAC7D;AACA,KAAK,8DAA8D;AACnE,KAAK,6DAA6D;AAClE,KAAK,yFAAyF;AAC9F,KAAK,4FAA4F;AACjG,KAAK,iEAAiE;AACtE,KAAK,yGAAyG;AAC9G,KAAK,0FAA0F;AAC/F,KAAK,8FAA8F;AACnG,KAAK,+DAA+D;AACpE,KAAK,gEAAgE;AACrE,KAAK,gEAAgE;AACrE;AACA;AACA;;;;;;;;AClBA;;AAEA;;AAEA,gBAAgB,eAAe;AAC/B;AACA,0CAA0C,eAAe;AACzD;AACA;AACA,0CAA0C,kCAAkC;AAC5E;AACA,4CAA4C,eAAe;AAC3D;AACA,cAAc;AACd;;AAEA,sBAAsB,eAAe;AACrC;AACA,iDAAiD,8BAA8B;AAC/E;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,iBAAiB;AACvC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C,eAAe,wBAAwB;AACvC;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gEAAgE,oCAAoC;AACpG;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;ACvEA;;AAEA;;AAEA,kBAAkB,gBAAgB;AAClC,kDAAkD,gBAAgB;AAClE;;AAEA,iBAAiB,gBAAgB;AACjC,iDAAiD,gBAAgB;AACjE;;AAEA,iBAAiB,mBAAmB;AACpC,iDAAiD,mBAAmB;AACpE;;AAEA,oBAAoB,qCAAqC;AACzD,oDAAoD,qCAAqC;AACzF;;AAEA,qBAAqB,mBAAmB;AACxC,qDAAqD,mBAAmB;AACxE;;AAEA,iCAAiC,2BAA2B;AAC5D,iEAAiE,2BAA2B;AAC5F;;AAEA,kBAAkB,mBAAmB;AACrC,kDAAkD,mBAAmB;AACrE;;AAEA,sBAAsB,2BAA2B;AACjD,sDAAsD,2BAA2B;AACjF;;AAEA,mBAAmB,mBAAmB;AACtC,mDAAmD,mBAAmB;AACtE;;AAEA,oBAAoB,mBAAmB;AACvC,oDAAoD,mBAAmB;AACvE;;AAEA,oBAAoB,mBAAmB;AACvC,oDAAoD,mBAAmB;AACvE;;AAEA;AACA;AACA;;;;;;;;;AClDA,aAAa,mBAAO,CAAC,GAAmB;AACxC,iBAAiB,mBAAO,CAAC,GAAuB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACTA,sC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UCtBA;UACA;UACA;UACA","file":"backend.js","sourcesContent":["module.exports = app => {\n  const aops = {};\n  return aops;\n};\n","module.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class FlowTask {\n\n    get modelFlowTask() {\n      return ctx.model.module(moduleInfo.relativeName).flowTask;\n    }\n    get modelFlowTaskHistory() {\n      return ctx.model.module(moduleInfo.relativeName).flowTaskHistory;\n    }\n\n    get sqlProcedure() {\n      return ctx.bean._getBean(moduleInfo.relativeName, 'local.procedure');\n    }\n\n    async count({ options, user }) {\n      return await this.select({ options, user, count: 1 });\n    }\n\n    async select({ options, user, pageForce = true, count = 0 }) {\n      const tasks = await this._list({ options, user, pageForce, count });\n      // loop\n      for (const task of tasks) {\n        // locale\n        task.flowNodeNameLocale = ctx.text(task.flowNodeName);\n        if (task.flowNodeRemark) {\n          task.flowNodeRemarkLocale = ctx.text(task.flowNodeRemark);\n        }\n        if (task.handleRemark) {\n          task.handleRemarkLocale = ctx.text(task.handleRemark);\n        }\n      }\n      return tasks;\n    }\n\n    async claim({ flowTaskId, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user });\n      return await taskInstance._claim();\n    }\n\n    async complete({ flowTaskId, handle, formAtom, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user });\n      await taskInstance._complete({ handle, formAtom });\n    }\n\n    async assignees({ flowTaskId, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user });\n      return await taskInstance._assignees();\n    }\n\n    async assigneesConfirmation({ flowTaskId, handle, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user });\n      await taskInstance._assigneesConfirmation({ handle });\n    }\n\n    async recall({ flowTaskId, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user });\n      await taskInstance._recall();\n    }\n\n    async cancelFlow({ flowTaskId, handle, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user });\n      await taskInstance._cancelFlow({ handle });\n    }\n\n    async actions({ flowTaskId, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user });\n      return await taskInstance._actions();\n    }\n\n    // from history\n    async viewAtom({ flowTaskId, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user, history: true });\n      return await taskInstance._viewAtom();\n    }\n\n    // from runtime\n    async editAtom({ flowTaskId, user }) {\n      // taskInstance\n      const taskInstance = await this._loadTaskInstance({ flowTaskId, user, history: false });\n      return await taskInstance._editAtom();\n    }\n\n    async _nodeDoneCheckLock({ flowNodeId }) {\n      // load flow node\n      const nodeInstance = await ctx.bean.flow._loadFlowNodeInstance({ flowNodeId });\n      // options\n      const options = this._getNodeDefOptionsTask({ nodeInstance });\n      // completionCondition\n      const completionCondition = options.completionCondition;\n      // task count\n      const taskCountTotal = await this.modelFlowTask.count({\n        flowNodeId,\n      });\n      if (taskCountTotal === 0) {\n        // means node has been checked and done\n        // XX //   should throw error to deny the db changed for tasks has been deleted.\n        // XX ctx.throw.module('a-flow', 1004, flowNodeId);\n        // neednot throw error for this method is called in ctx.tail\n        return;\n      }\n      const taskCountPassed = await this.modelFlowTask.count({\n        flowNodeId, flowTaskStatus: 1, handleStatus: 1,\n      });\n      const taskCountRejected = await this.modelFlowTask.count({\n        flowNodeId, flowTaskStatus: 1, handleStatus: 2,\n      });\n      // check passed\n      if (typeof completionCondition.passed === 'number' || completionCondition.passed.indexOf('%') === -1) {\n        // absolute value\n        if (taskCountPassed >= parseInt(completionCondition.passed)) {\n          return await this._nodeDoneCheckLock_passed({ nodeInstance });\n        }\n      } else {\n        // percent value\n        if (taskCountPassed / taskCountTotal >= parseInt(completionCondition.passed) / 100) {\n          return await this._nodeDoneCheckLock_passed({ nodeInstance });\n        }\n      }\n      // check rejected\n      if (typeof completionCondition.rejected === 'number' || completionCondition.rejected.indexOf('%') === -1) {\n        // absolute value\n        if (taskCountRejected >= parseInt(completionCondition.rejected)) {\n          return await this._nodeDoneCheckLock_rejected({ nodeInstance, options });\n        }\n      } else {\n        // percent value\n        if (taskCountRejected / taskCountTotal >= parseInt(completionCondition.rejected) / 100) {\n          return await this._nodeDoneCheckLock_rejected({ nodeInstance, options });\n        }\n      }\n      // here means not done\n    }\n\n    async _nodeDoneCheckLock_passed({ nodeInstance }) {\n      // delete tasks\n      await this._nodeDoneCheckLock_deleteTasks({ nodeInstance });\n      // next stage of flow node: end\n      return await nodeInstance.end();\n    }\n\n    async _nodeDoneCheckLock_rejected({ nodeInstance, options }) {\n      // rejectedNode\n      return await this._gotoFlowNodePrevious({ nodeInstance, rejectedNode: options.rejectedNode });\n    }\n\n    async _gotoFlowNodePrevious({ nodeInstance, rejectedNode, flowNodeRemark = 'Rejected' }) {\n      // flowNodeId\n      const flowNodeId = nodeInstance.contextNode._flowNodeId;\n      // rejectedNode\n      if (!rejectedNode) {\n        // find previous task node\n        const flowNode = await this._findFlowNodeHistoryPrevious({ nodeInstance });\n        if (!flowNode) ctx.throw.module('a-flow', 1006, flowNodeId);\n        rejectedNode = flowNode.flowNodeDefId;\n      }\n      // nodeInstancePrev\n      const nodeInstancePrev = await nodeInstance.flowInstance._findNodeInstanceNext({\n        nodeDefId: rejectedNode,\n        flowNodeIdPrev: flowNodeId,\n      });\n      // delete tasks\n      await this._nodeDoneCheckLock_deleteTasks({ nodeInstance });\n      // clear & enter\n      await nodeInstance._clear({ flowNodeHandleStatus: 2, flowNodeRemark });\n      return await nodeInstancePrev.enter();\n    }\n\n    async _findFlowNodeHistoryPrevious({ nodeInstance }) {\n      // flowNodeId\n      const flowNodeId = nodeInstance.contextNode._flowNodeId;\n      return await nodeInstance.flowInstance._findFlowNodeHistoryPrevious({\n        flowNodeId, cb: ({ /* flowNode*/ nodeDef }) => {\n          return nodeDef.type === 'startEventAtom' || nodeDef.type === 'activityUserTask';\n        },\n      });\n    }\n\n    async _nodeDoneCheckLock_deleteTasks({ nodeInstance }) {\n      await this._clearRemains({ nodeInstance });\n    }\n\n    async _list({ options: { where, orders, page, mode, history = 0 }, user, pageForce = true, count = 0 }) {\n      // special for mode\n      if (mode === 'claimings') {\n        where['a.flowTaskStatus'] = 0;\n        where['a.timeClaimed'] = null;\n        history = 0;\n      } else if (mode === 'handlings') {\n        where['a.flowTaskStatus'] = 0;\n        where['a.timeClaimed'] = { op: 'notNull' };\n        history = 0;\n      } else if (mode === 'completeds') {\n        where['a.flowTaskStatus'] = 1;\n        history = 1;\n      }\n      // page\n      page = ctx.bean.util.page(page, pageForce);\n      // select\n      const sql = this.sqlProcedure.selectTasks({\n        iid: ctx.instance.id,\n        userIdWho: user ? user.id : 0,\n        where, orders, page,\n        count,\n        history,\n      });\n      const res = await ctx.model.query(sql);\n      return count ? res[0]._count : res;\n    }\n\n    async _loadTaskInstance({ flowTaskId, user, history }) {\n      // get\n      let flowTask;\n      if (!history) {\n        flowTask = await this.modelFlowTask.get({ id: flowTaskId });\n      } else {\n        flowTask = await this.modelFlowTaskHistory.get({ flowTaskId });\n      }\n      if (!flowTask) ctx.throw.module(moduleInfo.relativeName, 1001, flowTaskId);\n      // load flow node\n      const nodeInstance = await ctx.bean.flow._loadFlowNodeInstance({ flowNodeId: flowTask.flowNodeId, history });\n      // load task\n      const task = this._createTaskInstance2({ nodeInstance });\n      await task._load({ flowTask, user, history });\n      return task;\n    }\n\n    _createTaskInstance2({ nodeInstance }) {\n      const task = ctx.bean._newBean(`${moduleInfo.relativeName}.local.flow.task`, {\n        nodeInstance,\n      });\n      return task;\n    }\n\n    async _createTaskInstance({ nodeInstance, userIdAssignee, user }) {\n      const task = this._createTaskInstance2({ nodeInstance });\n      await task.init({ userIdAssignee, user });\n      return task;\n    }\n\n    _getNodeDefOptionsTask({ nodeInstance }) {\n      // nodeDef\n      const nodeDef = nodeInstance.contextNode._nodeDef;\n      // options\n      const options = nodeInstance.getNodeDefOptions();\n      return nodeDef.type === 'startEventAtom' ? options.task : options;\n    }\n\n    async _clearRemains({ nodeInstance }) {\n      const flowNodeId = nodeInstance.contextNode._flowNodeId;\n      // notify\n      const _tasks = await this.modelFlowTask.select({\n        where: { flowNodeId },\n      });\n      for (const _task of _tasks) {\n        this._notifyTaskClaimings(_task.userIdAssignee);\n        this._notifyTaskHandlings(_task.userIdAssignee);\n      }\n      // flowTask delete\n      await this.modelFlowTask.delete({ flowNodeId });\n      // flowTaskHistory close\n      //    flowTaskStatus:1\n      //    handleStatus: not changed\n      await ctx.model.query(`\n        update aFlowTaskHistory set flowTaskStatus=1\n          where iid=? and deleted=0 and flowNodeId=? and flowTaskStatus=0\n        `, [ ctx.instance.id, flowNodeId ]);\n    }\n\n    _notifyTaskClaimings(userId) {\n      if (userId) {\n        ctx.bean.stats.notify({\n          module: moduleInfo.relativeName,\n          name: 'taskClaimings',\n          user: { id: userId },\n        });\n      }\n    }\n\n    _notifyTaskHandlings(userId) {\n      if (userId) {\n        ctx.bean.stats.notify({\n          module: moduleInfo.relativeName,\n          name: 'taskHandlings',\n          user: { id: userId },\n        });\n      }\n    }\n\n  }\n\n  return FlowTask;\n};\n","const FlowNodeActivityUserTaskBase = require('../common/flowNodeActivityUserTaskBase.js');\n\nmodule.exports = ctx => {\n  class FlowNode extends FlowNodeActivityUserTaskBase(ctx) {\n  }\n\n  return FlowNode;\n};\n","module.exports = ctx => {\n  class FlowNode extends ctx.app.meta.FlowNodeBase {\n    constructor(options) {\n      super(ctx, options);\n    }\n\n    async onNodeLeave() {\n      await super.onNodeLeave();\n      // end\n      await this.flowInstance._endFlow({\n        flowHandleStatus: 1,\n        flowRemark: 'Submitted',\n        atom: {\n          submit: true,\n        },\n      });\n      // also true\n      return true;\n    }\n\n  }\n\n  return FlowNode;\n};\n","const FlowNodeActivityUserTaskBase = require('../common/flowNodeActivityUserTaskBase.js');\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class FlowNode extends FlowNodeActivityUserTaskBase(ctx) {\n\n    get modelCondition() {\n      return ctx.model.module(moduleInfo.relativeName).flowNodeStartEventAtomCondition;\n    }\n\n    async deploy({ deploy, flowDefId, node }) {\n      if (deploy) {\n        await this._addCondition({ flowDefId, node });\n      } else {\n        // donot delete condition\n      }\n    }\n\n    async onNodeDoing() {\n      // super\n      await super.onNodeDoing();\n      // auto handle\n      await this._autoHandle();\n      // break\n      return false;\n    }\n\n    async _autoHandle() {\n      const flowId = this.context._flowId;\n      // select\n      const tasks = await ctx.bean.flowTask.select({\n        options: {\n          where: {\n            'a.flowId': flowId,\n            'a.flowTaskStatus': 0,\n          },\n          history: 0,\n        } });\n      const task = tasks[0];\n      const flowTaskId = task.id;\n      const user = { id: task.userIdAssignee };\n      // claim automatically always\n      await ctx.bean.flowTask.claim({ flowTaskId, user });\n      // complete automatically only on first-in\n      if (this.contextNode._flowNode.flowNodeIdPrev === 0) {\n        await ctx.bean.flowTask.complete({\n          flowTaskId,\n          handle: { status: 1 },\n          user,\n        });\n      }\n    }\n\n    async _addCondition({ flowDefId, node }) {\n      const atom = node.options && node.options.atom;\n      if (!atom || !atom.module || !atom.atomClassName) {\n        // donot delete condition\n        // throw error\n        throw new Error(`atom not set for startEventAtom: ${flowDefId}.${node.id}`);\n      }\n      // atomClass\n      const atomClass = await ctx.bean.atomClass.get({\n        module: atom.module,\n        atomClassName: atom.atomClassName,\n        atomClassIdParent: atom.atomClassIdParent || 0,\n      });\n      const conditionExpression = node.options.conditionExpression;\n      // get condition\n      const startEventId = node.id;\n      const _condition = await this.modelCondition.get({\n        flowDefId, startEventId,\n      });\n      if (_condition) {\n        // update\n        _condition.atomClassId = atomClass.id;\n        _condition.conditionExpression = conditionExpression;\n        await this.modelCondition.update(_condition);\n      } else {\n        // insert\n        await this.modelCondition.insert({\n          flowDefId, startEventId,\n          atomClassId: atomClass.id, conditionExpression,\n        });\n      }\n    }\n\n    async _match({ atom, userId }) {\n      // order by atomStatic/conditionExpression\n      const list = await ctx.model.query(`\n          select a.* from aFlowNodeStartEventAtomCondition a\n            left join aFlowDef b on a.flowDefId=b.id\n            left join aAtom c on b.atomId=c.id\n            where a.iid=? and a.atomClassId=?\n            order by c.atomStatic asc, a.conditionExpression desc\n        `, [ ctx.instance.id, atom.atomClassId ]);\n      for (const _condition of list) {\n        const flowInstance = await this._matchCondition({ _condition, atom, userId });\n        if (flowInstance) return flowInstance;\n      }\n      return null;\n    }\n\n    async _matchCondition(context) {\n      const { _condition, atom, userId } = context;\n      // check if valid\n      if (!(await this._checkConditionValid(context))) {\n        await this._deleteCondition(context);\n        return null;\n      }\n      // match conditionExpression\n      const conditionActive = _condition.conditionExpression;\n      if (conditionActive) {\n        const res = ctx.bean.flow.evaluateExpression({\n          expression: conditionActive,\n          globals: { atom },\n        });\n        if (!res) return null;\n      }\n      // start\n      const flowInstance = await ctx.bean.flow.startById({\n        flowDefId: _condition.flowDefId,\n        startEventId: _condition.startEventId,\n        flowUserId: userId,\n        flowAtomId: atom.atomId,\n      });\n      // ok\n      return flowInstance;\n    }\n\n    async _checkConditionValid(context) {\n      const { _condition } = context;\n      // flowDef\n      const flowDef = await ctx.bean.flowDef.getById({ flowDefId: _condition.flowDefId });\n      if (!flowDef) return false;\n      // atomDisabled\n      if (flowDef.atomDisabled === 1) return false;\n      // content\n      const content = flowDef.content ? JSON.parse(flowDef.content) : null;\n      if (!content) return false;\n      const nodeConfig = content.process.nodes.find(item => item.id === _condition.startEventId);\n      if (!nodeConfig) return false;\n      // check if changed\n      const conditionActive = _condition.conditionExpression;\n      const conditionConfig = nodeConfig.options && nodeConfig.options.conditionExpression;\n      if (conditionActive !== conditionConfig) return false;\n      // ok\n      return true;\n    }\n\n    async _deleteCondition(context) {\n      const { _condition } = context;\n      await this.modelCondition.delete({ id: _condition.id });\n    }\n\n  }\n\n  return FlowNode;\n};\n\n","module.exports = ctx => {\n  class IOMessage extends ctx.app.meta.IOMessageBase(ctx) {\n  }\n  return IOMessage;\n};\n","module.exports = ctx => {\n\n  class ContextTask {\n\n    constructor({ context, contextNode, nodeDef }) {\n      this.context = context;\n      this.contextNode = contextNode;\n      this._nodeDef = nodeDef;\n      //\n      this._flowTaskId = null;\n      this._flowTask = null;\n      this._flowTaskHistory = null;\n      this._taskVars = null;\n      //\n      this._utils = null;\n      //\n      this._user = null;\n    }\n\n    get vars() {\n      return this._taskVars;\n    }\n\n    get utils() {\n      return this._utils;\n    }\n\n  }\n\n  return ContextTask;\n};\n","const require3 = require('require3');\nconst extend = require3('extend2');\nconst VarsFn = require('../common/vars.js');\nconst UtilsFn = require('../common/utils.js');\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class FlowTask {\n    constructor({ nodeInstance }) {\n      this.nodeInstance = nodeInstance;\n      this.flowInstance = nodeInstance.flowInstance;\n      this.context = nodeInstance.context;\n      this.contextNode = nodeInstance.contextNode;\n      // context\n      this.contextTask = ctx.bean._newBean(`${moduleInfo.relativeName}.local.context.task`, {\n        context: nodeInstance.context,\n        contextNode: nodeInstance.contextNode,\n        nodeDef: nodeInstance.contextNode._nodeDef,\n      });\n    }\n\n    get modelFlowTask() {\n      return ctx.model.module(moduleInfo.relativeName).flowTask;\n    }\n    get modelFlowTaskHistory() {\n      return ctx.model.module(moduleInfo.relativeName).flowTaskHistory;\n    }\n\n    async init({ userIdAssignee, user }) {\n      // create flowTask\n      const flowTaskId = await this._createFlowTask({ userIdAssignee, user });\n      // context init\n      await this._contextInit({ flowTaskId, user });\n      // event\n      await this.created();\n    }\n\n    async _load({ flowTask, user, history }) {\n      // context init\n      await this._contextInit({ flowTaskId: flowTask.id, user, history });\n    }\n\n    async _createFlowTask({ userIdAssignee, user }) {\n      // flowTask\n      const data = {\n        flowId: this.context._flowId,\n        flowNodeId: this.contextNode._flowNodeId,\n        flowTaskStatus: 0,\n        userIdAssignee,\n        specificFlag: 0,\n        taskVars: '{}',\n      };\n      const res = await this.modelFlowTask.insert(data);\n      const flowTaskId = res.insertId;\n      // flowTaskHistory\n      data.flowTaskId = flowTaskId;\n      await this.modelFlowTaskHistory.insert(data);\n      // notify\n      this._notifyTaskClaimings(userIdAssignee);\n      // publish uniform message\n      if (userIdAssignee !== user.id) {\n        const userFlow = await ctx.bean.user.get({ id: this.context._flow.flowUserId });\n        const userAssignee = await ctx.bean.user.get({ id: userIdAssignee });\n        const title = `${ctx.text.locale(userAssignee.locale, 'Task')} - ${ctx.text.locale(userAssignee.locale, this.contextNode._flowNode.flowNodeName)}`;\n        const actionPath = `/a/flowtask/flow?flowId=${this.context._flowId}&flowTaskId=${flowTaskId}`;\n        const message = {\n          userIdTo: userIdAssignee,\n          content: {\n            issuerId: userFlow.id,\n            issuerName: userFlow.userName,\n            issuerAvatar: userFlow.avatar,\n            title,\n            body: this.context._flow.flowName,\n            actionPath,\n            params: {\n              flowId: this.context._flowId,\n              flowTaskId,\n            },\n          },\n        };\n        // jump out of the transaction\n        ctx.tail(async () => {\n          await ctx.bean.io.publish({\n            message,\n            messageClass: {\n              module: 'a-flow',\n              messageClassName: 'workflow',\n            },\n          });\n        });\n      }\n      // ok\n      return flowTaskId;\n    }\n\n    async _contextInit({ flowTaskId, user, history }) {\n      // flowTaskId\n      this.contextTask._flowTaskId = flowTaskId;\n      // flowTask\n      if (!history) {\n        this.contextTask._flowTask = await this.modelFlowTask.get({ id: flowTaskId });\n      }\n      this.contextTask._flowTaskHistory = await this.modelFlowTaskHistory.get({ flowTaskId });\n      // taskVars\n      this.contextTask._taskVars = new (VarsFn())();\n      this.contextTask._taskVars._vars = this.contextTask._flowTaskHistory.taskVars ? JSON.parse(this.contextTask._flowTaskHistory.taskVars) : {};\n      // utils\n      this.contextTask._utils = new (UtilsFn({ ctx, flowInstance: this.flowInstance }))({\n        context: this.context,\n        contextNode: this.contextNode,\n        contextTask: this.contextTask,\n      });\n      // user\n      this.contextTask._user = user;\n    }\n\n    async _hidden({ hidden }) {\n      // flowTask\n      const flowTaskHidden = hidden ? 1 : 0;\n      this.contextTask._flowTask.flowTaskHidden = flowTaskHidden;\n      await this.modelFlowTask.update(this.contextTask._flowTask);\n      // history\n      this.contextTask._flowTaskHistory.flowTaskHidden = flowTaskHidden;\n      await this.modelFlowTaskHistory.update(this.contextTask._flowTaskHistory);\n    }\n\n    async _claim() {\n      // user\n      const user = this.contextTask._user;\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // check: not throw error\n      // if (flowTask.timeClaimed) ctx.throw.module(moduleInfo.relativeName, 1003, flowTaskId);\n      if (flowTask.timeClaimed) {\n        return { timeClaimed: flowTask.timeClaimed };\n      }\n      // flowTask\n      const timeClaimed = new Date();\n      this.contextTask._flowTask.timeClaimed = timeClaimed;\n      this.contextTask._flowTask.flowTaskHidden = 0; // show\n      await this.modelFlowTask.update(this.contextTask._flowTask);\n      // history\n      this.contextTask._flowTaskHistory.timeClaimed = timeClaimed;\n      this.contextTask._flowTaskHistory.flowTaskHidden = 0; // show\n      await this.modelFlowTaskHistory.update(this.contextTask._flowTaskHistory);\n      // delete recall task: (specificFlag=2)\n      const _taskRecall = await ctx.model.queryOne(`\n          select id,userIdAssignee from aFlowTask\n            where iid=? and deleted=0 and flowNodeId=? and specificFlag=2\n          `, [ ctx.instance.id, flowTask.flowNodeId ]);\n      if (_taskRecall) {\n        this._notifyTaskHandlings(_taskRecall.userIdAssignee);\n        // delete task\n        await ctx.model.query(`\n          delete from aFlowTask\n            where iid=? and id=?\n          `, [ ctx.instance.id, _taskRecall.id ]);\n        await ctx.model.query(`\n          update aFlowTaskHistory set deleted=1\n            where iid=? and deleted=0 and flowTaskId=?\n          `, [ ctx.instance.id, _taskRecall.id ]);\n      }\n      // check if bidding\n      const options = ctx.bean.flowTask._getNodeDefOptionsTask({ nodeInstance: this.nodeInstance });\n      if (options.bidding) {\n        // notify\n        const _tasks = await ctx.model.query(`\n          select id,userIdAssignee from aFlowTask\n            where iid=? and deleted=0 and flowNodeId=? and id<>?\n          `, [ ctx.instance.id, flowTask.flowNodeId, flowTaskId ]);\n        for (const _task of _tasks) {\n          this._notifyTaskClaimings(_task.userIdAssignee);\n        }\n        // delete other tasks\n        await ctx.model.query(`\n          delete from aFlowTask\n            where iid=? and flowNodeId=? and id<>?\n          `, [ ctx.instance.id, flowTask.flowNodeId, flowTaskId ]);\n        await ctx.model.query(`\n          update aFlowTaskHistory set deleted=1\n            where iid=? and deleted=0 and flowNodeId=? and flowTaskId<>?\n          `, [ ctx.instance.id, flowTask.flowNodeId, flowTaskId ]);\n      }\n      // event: task.claimed\n      await this.claimed();\n      // notify\n      this._notifyTaskClaimings(flowTask.userIdAssignee);\n      this._notifyTaskHandlings(flowTask.userIdAssignee);\n      // ok\n      return { timeClaimed };\n    }\n\n    async _complete({ handle, formAtom }) {\n      // user\n      const user = this.contextTask._user;\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // specificFlag must be 0\n      if (flowTask.specificFlag !== 0) ctx.throw(403);\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // timeClaimed first\n      if (!flowTask.timeClaimed) ctx.throw.module(moduleInfo.relativeName, 1004, flowTaskId);\n      // check handled\n      if (flowTask.flowTaskStatus !== 0) ctx.throw.module(moduleInfo.relativeName, 1005, flowTaskId);\n      // check if pass/reject\n      if (handle) {\n        const options = ctx.bean.flowTask._getNodeDefOptionsTask({ nodeInstance: this.nodeInstance });\n        if (handle.status === 1 && !options.allowPassTask) {\n          ctx.throw.module(moduleInfo.relativeName, 1006, flowTaskId);\n        }\n        if (handle.status === 2 && !options.allowRejectTask) {\n          ctx.throw.module(moduleInfo.relativeName, 1007, flowTaskId);\n        }\n      }\n      // formAtom\n      if (formAtom) {\n        await this._complete_formAtom({ formAtom });\n      }\n      // handle\n      if (handle) {\n        await this._complete_handle({ handle });\n        // event: task.completed\n        await this.completed();\n        // check if node done\n        ctx.tail(async () => {\n          await this._complete_tail({ flowTask, user });\n        });\n        // notify\n        this._notifyTaskHandlings(flowTask.userIdAssignee);\n      }\n    }\n\n    async _complete_tail({ flowTask, user }) {\n      const flowNodeId = flowTask.flowNodeId;\n      await ctx.app.meta.util.lock({\n        subdomain: ctx.subdomain,\n        resource: `${moduleInfo.relativeName}.flowTask.nodeDoneCheck.${flowNodeId}`,\n        fn: async () => {\n          return await ctx.app.meta.util.executeBean({\n            subdomain: ctx.subdomain,\n            beanModule: moduleInfo.relativeName,\n            beanFullName: 'flowTask',\n            context: { flowNodeId },\n            fn: '_nodeDoneCheckLock',\n            transaction: true,\n            ctxParent: { state: { user: { op: user } } },\n          });\n        },\n      });\n    }\n\n    async _assignees() {\n      // user\n      const user = this.contextTask._user;\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // specificFlag must be 1\n      if (flowTask.specificFlag !== 1) ctx.throw(403);\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // timeClaimed first\n      if (!flowTask.timeClaimed) ctx.throw.module(moduleInfo.relativeName, 1004, flowTaskId);\n      // check handled\n      if (flowTask.flowTaskStatus !== 0) ctx.throw.module(moduleInfo.relativeName, 1005, flowTaskId);\n      // handle\n      return await this._assignees_handle();\n    }\n\n    async _assignees_handle() {\n      // assignees\n      const assignees = this.contextNode.vars.get('_assignees');\n      // users\n      let users;\n      if (!assignees || assignees.length === 0) {\n        users = [];\n      } else {\n        users = await ctx.bean.user.select({\n          options: {\n            where: {\n              'a.disabled': 0,\n              'a.id': assignees,\n            },\n            orders: [[ 'a.userName', 'asc' ]],\n            removePrivacy: true,\n          },\n        });\n      }\n      // options\n      const options = ctx.bean.flowTask._getNodeDefOptionsTask({ nodeInstance: this.nodeInstance });\n      // ok\n      return {\n        users,\n        options: {\n          confirmationAllowAppend: options.confirmationAllowAppend,\n        },\n      };\n    }\n\n    async _cancelFlow({ handle }) {\n      // user\n      const user = this.contextTask._user;\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // specificFlag must be 0\n      if (flowTask.specificFlag !== 0) ctx.throw(403);\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // check handled\n      if (flowTask.flowTaskStatus !== 0) ctx.throw.module(moduleInfo.relativeName, 1005, flowTaskId);\n      // check if allowCancelFlow\n      const options = ctx.bean.flowTask._getNodeDefOptionsTask({ nodeInstance: this.nodeInstance });\n      if (!options.allowCancelFlow) {\n        ctx.throw.module(moduleInfo.relativeName, 1010, flowTaskId);\n      }\n      // handle\n      await this._cancelFlow_handle({ handle });\n    }\n\n    async _cancelFlow_handle({ handle }) {\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // close draft\n      const atomId = this.context._flow.flowAtomId;\n      if (atomId) {\n        await ctx.bean.atom.closeDraft({ key: { atomId } });\n      }\n      // notify\n      this._notifyTaskHandlings(flowTask.userIdAssignee);\n      // delete flowTask\n      await this.modelFlowTask.delete({ id: flowTaskId });\n      // flowTaskHistory update\n      this.contextTask._flowTaskHistory.flowTaskStatus = 1;\n      this.contextTask._flowTaskHistory.timeHandled = new Date();\n      this.contextTask._flowTaskHistory.handleStatus = 3;\n      this.contextTask._flowTaskHistory.handleRemark = handle.remark;\n      await this.modelFlowTaskHistory.update(this.contextTask._flowTaskHistory);\n      // node clear\n      //    not use handle.remark\n      const remark = 'Cancelled';// handle.remark;\n      await this.nodeInstance._clear({ flowNodeHandleStatus: 3, flowNodeRemark: remark });\n      // end flow\n      await this.flowInstance._endFlow({ flowHandleStatus: 3, flowRemark: remark });\n    }\n\n    async _recall() {\n      // user\n      const user = this.contextTask._user;\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // specificFlag must be 2\n      if (flowTask.specificFlag !== 2) ctx.throw(403);\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // timeClaimed first\n      if (!flowTask.timeClaimed) ctx.throw.module(moduleInfo.relativeName, 1004, flowTaskId);\n      // check handled\n      if (flowTask.flowTaskStatus !== 0) ctx.throw.module(moduleInfo.relativeName, 1005, flowTaskId);\n      // handle\n      await this._recall_handle();\n      // notify\n      this._notifyTaskHandlings(flowTask.userIdAssignee);\n    }\n\n    async _recall_handle() {\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // flowTaskHistory update\n      this.contextTask._flowTaskHistory.flowTaskStatus = 1;\n      this.contextTask._flowTaskHistory.timeHandled = new Date();\n      this.contextTask._flowTaskHistory.handleStatus = 1;\n      await this.modelFlowTaskHistory.update(this.contextTask._flowTaskHistory);\n      // delete flowTask and flowTaskHistory\n      await this.modelFlowTask.delete({ id: flowTaskId });\n      await this.modelFlowTaskHistory.delete({ flowTaskId });\n      // notify\n      const _tasks = await ctx.model.query(`\n          select id,userIdAssignee from aFlowTask\n            where iid=? and deleted=0 and flowNodeId=? and id<>?\n          `, [ ctx.instance.id, flowTask.flowNodeId, flowTaskId ]);\n      for (const _task of _tasks) {\n        this._notifyTaskClaimings(_task.userIdAssignee);\n      }\n      // delete other tasks\n      await ctx.model.query(`\n          delete from aFlowTask\n            where iid=? and flowNodeId=? and id<>?\n          `, [ ctx.instance.id, flowTask.flowNodeId, flowTaskId ]);\n      await ctx.model.query(`\n          update aFlowTaskHistory set deleted=1\n            where iid=? and deleted=0 and flowNodeId=? and flowTaskId<>?\n          `, [ ctx.instance.id, flowTask.flowNodeId, flowTaskId ]);\n      // recall\n      return await ctx.bean.flowTask._gotoFlowNodePrevious({\n        nodeInstance: this.nodeInstance, rejectedNode: null, flowNodeRemark: 'Recalled',\n      });\n    }\n\n    async _assigneesConfirmation({ handle }) {\n      // user\n      const user = this.contextTask._user;\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // specificFlag must be 1\n      if (flowTask.specificFlag !== 1) ctx.throw(403);\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // timeClaimed first\n      if (!flowTask.timeClaimed) ctx.throw.module(moduleInfo.relativeName, 1004, flowTaskId);\n      // check handled\n      if (flowTask.flowTaskStatus !== 0) ctx.throw.module(moduleInfo.relativeName, 1005, flowTaskId);\n      // handle\n      await this._assigneesConfirmation_handle({ handle });\n      // notify\n      this._notifyTaskHandlings(flowTask.userIdAssignee);\n    }\n\n    async _assigneesConfirmation_handle({ handle }) {\n      // options\n      const options = ctx.bean.flowTask._getNodeDefOptionsTask({ nodeInstance: this.nodeInstance });\n      // flowTaskHistory update\n      this.contextTask._flowTaskHistory.flowTaskStatus = 1;\n      this.contextTask._flowTaskHistory.timeHandled = new Date();\n      this.contextTask._flowTaskHistory.handleStatus = handle.status;\n      await this.modelFlowTaskHistory.update(this.contextTask._flowTaskHistory);\n      // delete flowTask and flowTaskHistory\n      const flowTaskId = this.contextTask._flowTaskId;\n      await this.modelFlowTask.delete({ id: flowTaskId });\n      await this.modelFlowTaskHistory.delete({ flowTaskId });\n      // passed\n      if (handle.status === 1) {\n        // assignees\n        const assignees = await this.flowInstance._parseAssignees(handle.assignees);\n        if (!assignees || assignees.length === 0) {\n          ctx.throw.module(moduleInfo.relativeName, 1008, flowTaskId);\n        }\n        // check confirmationAllowAppend\n        if (!options.confirmationAllowAppend) {\n          const assigneesOld = this.contextNode.vars.get('_assignees');\n          if (!(new Set(assigneesOld)).isSuperset(new Set(assignees))) {\n            ctx.throw.module(moduleInfo.relativeName, 1009, flowTaskId);\n          }\n        }\n        // save var: _assigneesConfirmation\n        this.contextNode.vars.set('_assigneesConfirmation', assignees);\n        // next stage of flow node: begin\n        return await this.nodeInstance.begin();\n      }\n      // reject\n      if (handle.status === 2) {\n        return await ctx.bean.flowTask._gotoFlowNodePrevious({\n          nodeInstance: this.nodeInstance, rejectedNode: null,\n        });\n      }\n    }\n\n    async _complete_formAtom({ formAtom }) {\n      // schemaWrite\n      const schemaWrite = await this._getSchemaWrite();\n      if (!schemaWrite) return;\n      // write\n      const atomId = this.context._atom.atomId;\n      const user = this.contextTask._user;\n      await ctx.bean.atom.write({\n        key: { atomId }, item: formAtom,\n        options: { schema: schemaWrite },\n        user,\n      });\n    }\n\n    async _complete_handle({ handle }) {\n      const timeHandled = new Date();\n      // flowTask\n      this.contextTask._flowTask.flowTaskStatus = 1;\n      this.contextTask._flowTask.timeHandled = timeHandled;\n      this.contextTask._flowTask.handleStatus = handle.status;\n      this.contextTask._flowTask.handleRemark = handle.remark;\n      await this.modelFlowTask.update(this.contextTask._flowTask);\n      // flowTaskHistory\n      this.contextTask._flowTaskHistory.flowTaskStatus = 1;\n      this.contextTask._flowTaskHistory.timeHandled = timeHandled;\n      this.contextTask._flowTaskHistory.handleStatus = handle.status;\n      this.contextTask._flowTaskHistory.handleRemark = handle.remark;\n      await this.modelFlowTaskHistory.update(this.contextTask._flowTaskHistory);\n    }\n\n    async _actions() {\n      // user\n      const user = this.contextTask._user;\n      // flowTask\n      const flowTask = this.contextTask._flowTask;\n      const flowTaskId = flowTask.id;\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // flowTaskStatus\n      if (flowTask.flowTaskStatus === 1) return null;\n      // actions\n      const actions = [];\n      // specificFlag\n      if (flowTask.specificFlag === 1) {\n        actions.push({\n          name: 'assigneesConfirmation',\n        });\n      } else if (flowTask.specificFlag === 2) {\n        actions.push({\n          name: 'recall',\n        });\n      } else if (flowTask.specificFlag === 0) {\n        // options\n        const options = ctx.bean.flowTask._getNodeDefOptionsTask({ nodeInstance: this.nodeInstance });\n        // allowPassTask allowRejectTask\n        if (options.allowPassTask || options.allowRejectTask) {\n          actions.push({\n            name: 'handleTask',\n            options: {\n              allowPassTask: options.allowPassTask,\n              allowRejectTask: options.allowRejectTask,\n            },\n          });\n        }\n        // allowCancelFlow\n        if (options.allowCancelFlow) {\n          actions.push({\n            name: 'cancelFlow',\n          });\n        }\n      }\n      // others\n      return actions;\n    }\n\n    async _viewAtom() {\n      return await this._getAtomAndSchema({ mode: 'read' });\n    }\n\n    async _editAtom() {\n      return await this._getAtomAndSchema({ mode: 'write' });\n    }\n\n    async _getAtomAndSchema({ mode }) {\n      // user/atom\n      const user = this.contextTask._user;\n      const atom = this.context._atom;\n      // flowTask\n      const flowTask = this.contextTask._flowTaskHistory;\n      const flowTaskId = flowTask.flowTaskId;\n      // must be the same user\n      if (user && user.id !== 0 && user.id !== flowTask.userIdAssignee) ctx.throw.module(moduleInfo.relativeName, 1002, flowTaskId);\n      // must be the same flowId, means not outdated\n      if (atom.atomFlowId !== this.context._flowId) ctx.throw.module('a-flow', 1009, this.context._flowId);\n      // special for write\n      if (mode === 'write') {\n        // check handled\n        if (flowTask.flowTaskStatus !== 0) ctx.throw.module(moduleInfo.relativeName, 1005, flowTaskId);\n      }\n      // schema\n      let schema = await this._getSchema({ mode });\n      if (!schema) return null;\n      // item\n      const item = extend(true, {}, atom);\n      // validate\n      await ctx.bean.validation._validate({\n        data: item,\n        options: { schema },\n      });\n      // get real schema\n      schema = ctx.bean.validation.getSchema(schema);\n      // basic fields\n      const fields = await ctx.bean.atom.modelAtom.columns();\n      fields.atomId = {};\n      fields.module = {};\n      fields.atomClassName = {};\n      fields.atomCategoryName = {};\n      for (const field in fields) {\n        item[field] = atom[field];\n      }\n      // ok\n      return { schema, item };\n    }\n\n    async _getSchemaRead() {\n      return await this._getSchema({ mode: 'read' });\n    }\n\n    async _getSchemaWrite() {\n      return await this._getSchema({ mode: 'write' });\n    }\n\n    // mode: read/write\n    async _getSchema({ mode }) {\n      const module = this.context._atom.module;\n      // options\n      const options = ctx.bean.flowTask._getNodeDefOptionsTask({ nodeInstance: this.nodeInstance });\n      const fields = options.schema && options.schema[mode];\n      if (!fields) return null;\n      // { module, validator, schema }\n      if (fields && !Array.isArray(fields) && typeof fields === 'object') {\n        return {\n          module: fields.module,\n          validator: fields.validator,\n          schema: fields.schema,\n        };\n      }\n      // base\n      let schemaBase = await this._getSchemaBase();\n      // full read/write\n      if (fields === true && schemaBase) {\n        return {\n          module: schemaBase.module,\n          validator: schemaBase.validator,\n        };\n      }\n      if (!schemaBase) {\n        schemaBase = {\n          module,\n          schema: { type: 'object', properties: {} },\n        };\n      }\n      // some fields\n      const propertiesBase = schemaBase.schema.properties;\n      // properties\n      const properties = {};\n      for (const field of fields) {\n        if (typeof field === 'string') {\n          if (propertiesBase[field]) {\n            properties[field] = propertiesBase[field];\n          }\n        } else {\n          // { name, property }\n          properties[field.name] = field.property;\n        }\n      }\n      // schema\n      let schema = {\n        module,\n        schema: { type: 'object', properties },\n      };\n      // listener\n      const methodName = `getSchema${mode.replace(mode[0], mode[0].toUpperCase())}`;\n      const res = await this.flowInstance._flowListener[methodName](this.contextTask, this.contextNode, { schemaBase, schema });\n      if (res) {\n        schema = res;\n      }\n      // ok\n      return schema;\n    }\n\n    async _getSchemaBase() {\n      const atomClassId = this.context._atom.atomClassId;\n      const schema = await ctx.bean.atom.schema({\n        atomClass: { id: atomClassId },\n      });\n      return schema;\n    }\n\n    async _saveTaskVars() {\n      if (!this.contextTask._taskVars._dirty) return;\n      // flowTask\n      this.contextTask._flowTask.taskVars = JSON.stringify(this.contextTask._taskVars._vars);\n      await this.modelFlowTask.update(this.contextTask._flowTask);\n      // flowTask history\n      this.contextTask._flowTaskHistory.taskVars = this.contextTask._flowTask.taskVars;\n      await this.modelFlowTaskHistory.update(this.contextTask._flowTaskHistory);\n      // done\n      this.contextTask._taskVars._dirty = false;\n    }\n\n    async _saveVars() {\n      // save taskVars\n      await this._saveTaskVars();\n      // save nodeVars\n      await this.nodeInstance._saveNodeVars();\n      // save flowVars\n      await this.flowInstance._saveFlowVars();\n    }\n\n    async created() {\n      // raise event: onTaskCreated\n      await this.flowInstance._flowListener.onTaskCreated(this.contextTask, this.contextNode);\n      await this._saveVars();\n    }\n\n    async claimed() {\n      // raise event: onTaskClaimed\n      await this.flowInstance._flowListener.onTaskClaimed(this.contextTask, this.contextNode);\n      await this._saveVars();\n    }\n\n    async completed() {\n      // raise event: onTaskCompleted\n      await this.flowInstance._flowListener.onTaskCompleted(this.contextTask, this.contextNode);\n      await this._saveVars();\n    }\n\n    _notifyTaskClaimings(userId) {\n      ctx.bean.flowTask._notifyTaskClaimings(userId);\n    }\n\n    _notifyTaskHandlings(userId) {\n      ctx.bean.flowTask._notifyTaskHandlings(userId);\n    }\n\n  }\n  return FlowTask;\n};\n","module.exports = ctx => {\n  class Procedure {\n\n    selectTasks({ iid, userIdWho, where, orders, page, count, history }) {\n      iid = parseInt(iid);\n      userIdWho = parseInt(userIdWho);\n      history = parseInt(history);\n\n      // history\n      if (history === 0) {\n        return this._selectTasks_0({ iid, userIdWho, where, orders, page, count });\n      }\n      return this._selectTasks_1({ iid, userIdWho, where, orders, page, count });\n    }\n\n    _selectTasks_0({ iid, userIdWho, where, orders, page, count }) {\n      // -- tables\n      // -- a: aFlowTask\n      // -- b: aFlowNode\n      // -- c: aFlow\n      // -- d: aUser\n      // -- e: aUser(for flowUserId)\n\n      // for safe\n      where = where ? ctx.model._where(where) : null;\n      orders = orders ? ctx.model._orders(orders) : null;\n      const limit = page ? ctx.model._limit(page.size, page.index) : null;\n\n      // vars\n      let _userWhere;\n\n      //\n      const _where = where ? `${where} AND` : ' WHERE';\n      const _orders = orders || '';\n      const _limit = limit || '';\n\n      // user\n      if (userIdWho !== 0) {\n        _userWhere = ` and a.userIdAssignee=${userIdWho}`;\n      } else {\n        _userWhere = '';\n      }\n\n      // fields\n      let _selectFields;\n      if (count) {\n        _selectFields = 'count(*) as _count';\n      } else {\n        _selectFields = `a.*,a.id as flowTaskId,\n            b.flowNodeDefId,b.flowNodeName,b.flowNodeType,\n            c.flowDefId,c.flowDefKey,c.flowDefRevision,c.flowName,c.flowStatus,c.flowAtomId,c.flowNodeIdCurrent,c.flowUserId,\n            d.userName,d.avatar,\n            e.userName as flowUserName,e.avatar as flowUserAvatar\n          `;\n      }\n\n      // sql\n      const _sql =\n        `select ${_selectFields} from aFlowTask a\n            inner join aFlowNode b on a.flowNodeId=b.id\n            inner join aFlow c on a.flowId=c.id\n            left join aUser d on a.userIdAssignee=d.id\n            left join aUser e on c.flowUserId=e.id\n\n          ${_where}\n           (\n             a.deleted=0 and a.iid=${iid}\n             ${_userWhere}\n           )\n\n          ${count ? '' : _orders}\n          ${count ? '' : _limit}\n        `;\n\n      // ok\n      return _sql;\n    }\n\n    _selectTasks_1({ iid, userIdWho, where, orders, page, count }) {\n      // -- tables\n      // -- a: aFlowTaskHistory\n      // -- b: aFlowNodeHistory\n      // -- c: aFlowHistory\n      // -- d: aUser\n      // -- e: aUser(for flowUserId)\n\n      // for safe\n      where = where ? ctx.model._where(where) : null;\n      orders = orders ? ctx.model._orders(orders) : null;\n      const limit = page ? ctx.model._limit(page.size, page.index) : null;\n\n      // vars\n      let _userWhere;\n\n      //\n      const _where = where ? `${where} AND` : ' WHERE';\n      const _orders = orders || '';\n      const _limit = limit || '';\n\n      // user\n      if (userIdWho !== 0) {\n        _userWhere = ` and a.userIdAssignee=${userIdWho}`;\n      } else {\n        _userWhere = '';\n      }\n\n      // fields\n      let _selectFields;\n      if (count) {\n        _selectFields = 'count(*) as _count';\n      } else {\n        _selectFields = `a.*,\n            b.flowNodeDefId,b.flowNodeName,b.flowNodeType,b.flowNodeStatus,b.flowNodeRemark,b.timeDone,\n            c.flowDefId,c.flowDefKey,c.flowDefRevision,c.flowName,c.flowStatus,c.flowAtomId,c.flowNodeIdCurrent,c.flowUserId,\n            d.userName,d.avatar,\n            e.userName as flowUserName,e.avatar as flowUserAvatar\n          `;\n      }\n\n      // sql\n      const _sql =\n        `select ${_selectFields} from aFlowTaskHistory a\n            inner join aFlowNodeHistory b on a.flowNodeId=b.flowNodeId\n            inner join aFlowHistory c on a.flowId=c.flowId\n            left join aUser d on a.userIdAssignee=d.id\n            left join aUser e on c.flowUserId=e.id\n\n          ${_where}\n           (\n             a.deleted=0 and a.iid=${iid}\n             ${_userWhere}\n           )\n\n          ${count ? '' : _orders}\n          ${count ? '' : _limit}\n        `;\n\n      // ok\n      return _sql;\n    }\n\n  }\n\n  return Procedure;\n\n};\n","module.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Stats {\n\n    async execute(context) {\n      const { user } = context;\n      const modelFlowTask = ctx.model.module(moduleInfo).flowTask;\n      const count = await modelFlowTask.count({\n        userIdAssignee: user.id,\n        flowTaskStatus: 0,\n        timeClaimed: null,\n      });\n      return count;\n    }\n\n  }\n\n  return Stats;\n};\n","module.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Stats {\n\n    async execute(context) {\n      const { user } = context;\n      const modelFlowTask = ctx.model.module(moduleInfo).flowTask;\n      const count = await modelFlowTask.count({\n        userIdAssignee: user.id,\n        flowTaskStatus: 0,\n        timeClaimed: { op: 'notNull' },\n      });\n      return count;\n    }\n\n  }\n\n  return Stats;\n};\n","module.exports = app => {\n  class Version extends app.meta.BeanBase {\n\n    async update(options) {\n      if (options.version === 1) {\n        let sql;\n\n        // create table: aFlowNodeStartEventAtomCondition\n        sql = `\n          CREATE TABLE aFlowNodeStartEventAtomCondition (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            flowDefId int(11) DEFAULT '0',\n            startEventId varchar(255) DEFAULT NULL,\n            atomClassId int(11) DEFAULT '0',\n            conditionExpression TEXT DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create table: aFlowTask\n        sql = `\n          CREATE TABLE aFlowTask (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            flowId int(11) DEFAULT '0',\n            flowNodeId int(11) DEFAULT '0',\n            flowTaskStatus int(11) DEFAULT '0',\n            flowTaskHidden int(11) DEFAULT '0',\n            userIdAssignee int(11) DEFAULT '0',\n            specificFlag int(11) DEFAULT '0',\n            handleStatus int(11) DEFAULT '0',\n            handleRemark TEXT DEFAULT NULL,\n            timeClaimed timestamp DEFAULT NULL,\n            timeHandled timestamp DEFAULT NULL,\n            taskVars JSON DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create table: aFlowTaskHistory\n        sql = `\n          CREATE TABLE aFlowTaskHistory (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            flowId int(11) DEFAULT '0',\n            flowTaskId int(11) DEFAULT '0',\n            flowNodeId int(11) DEFAULT '0',\n            flowTaskStatus int(11) DEFAULT '0',\n            flowTaskHidden int(11) DEFAULT '0',\n            userIdAssignee int(11) DEFAULT '0',\n            specificFlag int(11) DEFAULT '0',\n            handleStatus int(11) DEFAULT '0',\n            handleRemark TEXT DEFAULT NULL,\n            timeClaimed timestamp DEFAULT NULL,\n            timeHandled timestamp DEFAULT NULL,\n            taskVars JSON DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n      }\n    }\n\n    async init(options) {\n    }\n\n    async test() {\n    }\n\n  }\n\n  return Version;\n};\n","const versionManager = require('./bean/version.manager.js');\nconst flowNodeStartEventAtom = require('./bean/flow.node.startEventAtom.js');\nconst flowNodeEndEventAtom = require('./bean/flow.node.endEventAtom.js');\nconst flowNodeActivityUserTask = require('./bean/flow.node.activityUserTask.js');\nconst localContextTask = require('./bean/local.context.task.js');\nconst localFlowTask = require('./bean/local.flow.task.js');\nconst localProcedure = require('./bean/local.procedure.js');\nconst beanFlowTask = require('./bean/bean.flowTask.js');\nconst statsTaskClaimings = require('./bean/stats.taskClaimings.js');\nconst statsTaskHandlings = require('./bean/stats.taskHandlings.js');\nconst ioMessageWorkflow = require('./bean/io.message.workflow.js');\n\nmodule.exports = app => {\n  const beans = {\n    // version\n    'version.manager': {\n      mode: 'app',\n      bean: versionManager,\n    },\n    // flow\n    'flow.node.startEventAtom': {\n      mode: 'ctx',\n      bean: flowNodeStartEventAtom,\n    },\n    'flow.node.endEventAtom': {\n      mode: 'ctx',\n      bean: flowNodeEndEventAtom,\n    },\n    'flow.node.activityUserTask': {\n      mode: 'ctx',\n      bean: flowNodeActivityUserTask,\n    },\n    // local\n    'local.context.task': {\n      mode: 'ctx',\n      bean: localContextTask,\n    },\n    'local.flow.task': {\n      mode: 'ctx',\n      bean: localFlowTask,\n    },\n    'local.procedure': {\n      mode: 'ctx',\n      bean: localProcedure,\n    },\n    // global\n    flowTask: {\n      mode: 'ctx',\n      bean: beanFlowTask,\n      global: true,\n    },\n    // stats\n    'stats.taskClaimings': {\n      mode: 'ctx',\n      bean: statsTaskClaimings,\n    },\n    'stats.taskHandlings': {\n      mode: 'ctx',\n      bean: statsTaskHandlings,\n    },\n    // io\n    'io.message.workflow': {\n      mode: 'ctx',\n      bean: ioMessageWorkflow,\n    },\n  };\n  return beans;\n};\n","const require3 = require('require3');\nconst assert = require3('assert');\n\nmodule.exports = ctx => {\n  // const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class FlowNodeActivityUserTaskBase extends ctx.app.meta.FlowNodeBase {\n    constructor(options) {\n      super(ctx, options);\n    }\n\n    async onNodeEnter() {\n      // super\n      await super.onNodeEnter();\n\n      // options\n      const options = ctx.bean.flowTask._getNodeDefOptionsTask({\n        nodeInstance: this.nodeInstance,\n      });\n\n      // prepare assignees\n      const res = await this._prepareAssignees({ options });\n      if (!res) return false;\n\n      // ok\n      return true;\n    }\n\n    async onNodeBegin() {\n      // super\n      await super.onNodeBegin();\n\n      // options\n      const options = ctx.bean.flowTask._getNodeDefOptionsTask({\n        nodeInstance: this.nodeInstance,\n      });\n\n      // user\n      const user = this.flowInstance._getOpUser();\n\n      // var: _assigneesConfirmation\n      const assignees = this.contextNode.vars.get('_assigneesConfirmation');\n      assert(assignees && assignees.length > 0);\n\n      // recall\n      if (options.allowRecall) {\n        const taskInstance = await ctx.bean.flowTask._createTaskInstance({\n          nodeInstance: this.nodeInstance,\n          userIdAssignee: user.id,\n          user,\n        });\n        await this._taskConfirmationClaim({ taskInstance, specificFlag: 2 });\n      }\n\n      // create tasks\n      for (const userIdAssignee of assignees) {\n        const taskInstance = await ctx.bean.flowTask._createTaskInstance({\n          nodeInstance: this.nodeInstance,\n          userIdAssignee,\n          user,\n        });\n        if (!options.showAssignees) {\n          await taskInstance._hidden({ hidden: true });\n        }\n      }\n\n      // ok\n      return true;\n    }\n\n    async onNodeDoing() {\n      // super\n      await super.onNodeDoing();\n\n      // break\n      return false;\n    }\n\n    async clearRemains() {\n      await ctx.bean.flowTask._clearRemains({ nodeInstance: this.nodeInstance });\n    }\n\n    async _prepareAssignees({ options }) {\n      // check var: _assigneesConfirmation\n      let assignees = this.contextNode.vars.get('_assigneesConfirmation');\n      if (assignees && assignees.length > 0) return true;\n\n      // check var: _assignees\n      this.contextNode.vars.get('_assignees');\n      if (!assignees || assignees.length === 0) {\n        // assignees\n        assignees = await this.flowInstance._parseAssignees(options.assignees);\n      }\n\n      // confirmation\n      if (assignees.length === 0 || options.confirmation) {\n        // save var: _assignees\n        this.contextNode.vars.set('_assignees', assignees);\n        // user\n        const user = this.flowInstance._getOpUser();\n        const taskInstance = await ctx.bean.flowTask._createTaskInstance({\n          nodeInstance: this.nodeInstance,\n          userIdAssignee: user.id,\n          user,\n        });\n        await this._taskConfirmationClaim({ taskInstance, specificFlag: 1 });\n        // break\n        return false;\n      }\n\n      // save var: _assigneesConfirmation\n      this.contextNode.vars.set('_assigneesConfirmation', assignees);\n\n      // ok\n      return true;\n    }\n\n    async _taskConfirmationClaim({ taskInstance, specificFlag }) {\n      // specificFlag timeClaimed\n      const timeClaimed = new Date();\n      taskInstance.contextTask._flowTask.specificFlag = specificFlag;\n      taskInstance.contextTask._flowTask.timeClaimed = timeClaimed;\n      await taskInstance.modelFlowTask.update(taskInstance.contextTask._flowTask);\n      // history\n      taskInstance.contextTask._flowTaskHistory.specificFlag = specificFlag;\n      taskInstance.contextTask._flowTaskHistory.timeClaimed = timeClaimed;\n      await taskInstance.modelFlowTaskHistory.update(taskInstance.contextTask._flowTaskHistory);\n      // notify\n      taskInstance._notifyTaskClaimings(taskInstance.contextTask._flowTask.userIdAssignee);\n      taskInstance._notifyTaskHandlings(taskInstance.contextTask._flowTask.userIdAssignee);\n    }\n\n  }\n  return FlowNodeActivityUserTaskBase;\n};\n","module.exports = ({ ctx /* flowInstance*/ }) => {\n  class Utils {\n\n    constructor({ context, contextNode, contextTask }) {\n      this.context = context;\n      this.contextNode = contextNode;\n      this.contextTask = contextTask;\n    }\n\n    async executeService({ bean, parameter }) {\n      const globals = {};\n      if (this.context) globals.context = this.context;\n      if (this.contextNode) globals.contextNode = this.contextNode;\n      if (this.contextTask) globals.contextTask = this.contextTask;\n      return await ctx.bean.flow.executeService({\n        bean, parameter, globals,\n      });\n    }\n\n  }\n  return Utils;\n};\n","module.exports = () => {\n  class FlowVars {\n\n    constructor() {\n      this._vars = null;\n      this._dirty = false;\n    }\n\n    get(names) {\n      names = names.split('.');\n      let value = this._vars;\n      for (const name of names) {\n        value = value[name];\n        if (value === undefined) break;\n      }\n      return value;\n    }\n\n    set(names, value) {\n      names = names.split('.');\n      let obj = this._vars;\n      for (let i = 0; i < names.length - 1; i++) {\n        const name = names[i];\n        if (obj[name] === undefined) {\n          obj[name] = {};\n        }\n        obj = obj[name];\n      }\n      const name = names[names.length - 1];\n      obj[name] = value;\n      // dirty\n      this._dirty = true;\n    }\n\n  }\n  return FlowVars;\n};\n","// eslint-disable-next-line\nmodule.exports = appInfo => {\n  const config = {};\n  return config;\n};\n","// error code should start from 1001\nmodule.exports = {\n  1001: 'Task not Found: %s',\n  1002: 'Task cannot be accessed: %s',\n  1003: 'Task has been claimed: %s',\n  1004: 'Task should be claimed first: %s',\n  1005: 'Task has been handled: %s',\n  1006: 'Task cannot be passed: %s',\n  1007: 'Task cannot be rejected: %s',\n  1008: 'Task Assignees cannot be empty: %s',\n  1009: 'Task Assignees cannot be appended: %s',\n  1010: 'Flow cannot be cancelled: %s',\n};\n","module.exports = {\n  startEventAtom: {\n    atom: null,\n    conditionExpression: null,\n    task: {\n      assignees: {\n        users: null,\n        roles: null,\n        vars: 'flowUser',\n      },\n      showAssignees: false,\n      confirmation: false,\n      confirmationAllowAppend: false,\n      bidding: false,\n      completionCondition: {\n        passed: 1,\n        rejected: '100%',\n      },\n      rejectedNode: null,\n      allowPassTask: true,\n      allowRejectTask: false,\n      allowCancelFlow: true,\n      allowRecall: false,\n      schema: {\n        read: true,\n        write: true,\n      },\n    },\n  },\n  activityUserTask: {\n    assignees: {\n      users: null,\n      roles: null,\n      vars: null,\n    },\n    showAssignees: false,\n    confirmation: false,\n    confirmationAllowAppend: false,\n    bidding: false,\n    completionCondition: {\n      passed: 1,\n      rejected: '100%',\n    },\n    rejectedNode: null,\n    allowPassTask: true,\n    allowRejectTask: true,\n    allowCancelFlow: false,\n    allowRecall: true,\n    schema: {\n      read: true,\n      write: false,\n    },\n  },\n};\n","const defaults = require('./defaults.js');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  const nodes = {\n    // events\n    startEventAtom: {\n      title: 'StartEventAtom',\n      group: 'startEvent',\n      bean: 'startEventAtom',\n      icon: '/api/static/a/flowtask/bpmn/events/start-event-atom.svg',\n      validator: {\n        module: moduleInfo.relativeName,\n        validator: 'startEventAtom',\n      },\n    },\n    endEventAtom: {\n      title: 'EndEventAtom',\n      group: 'endEvent',\n      bean: 'endEventAtom',\n      icon: '/api/static/a/flowtask/bpmn/events/end-event-atom.svg',\n    },\n    // activities\n    activityUserTask: {\n      title: 'ActivityUserTask',\n      group: 'activity',\n      bean: 'activityUserTask',\n      icon: '/api/static/a/flowtask/bpmn/activities/activity-user-task.svg',\n      validator: {\n        module: moduleInfo.relativeName,\n        validator: 'activityUserTask',\n      },\n    },\n  };\n\n  for (const key in nodes) {\n    const node = nodes[key];\n    node.options = {};\n    if (defaults[key]) {\n      node.options.default = defaults[key];\n    }\n  }\n\n  return nodes;\n};\n","module.exports = {\n  StartEventAtom: 'StartEvent: Atom Draft',\n  EndEventAtom: 'EndEvent: Atom Submit',\n  ActivityUserTask: 'Activity: User Task',\n};\n","module.exports = {\n  Submitted: '已提交',\n  StartEventAtom: '原子起草开始事件',\n  EndEventAtom: '原子提交结束事件',\n  ActivityUserTask: '用户任务活动',\n  'Task not Found: %s': '任务未发现: %s',\n  'Task cannot be accessed: %s': '任务无权访问: %s',\n  'Task has been claimed: %s': '任务已被申领: %s',\n  'Task should be claimed first: %s': '任务必须先申领: %s',\n  'Task has been handled: %s': '任务已处理: %s',\n  'Task cannot be passed: %s': '任务无权被通过: %s',\n  'Task cannot be rejected: %s': '任务无权被拒绝: %s',\n  'Task Assignees cannot be empty: %s': '任务参与人不允许为空: %s',\n  'Task Assignees cannot be appended: %s': '任务参与人不允许追加: %s',\n  'Flow cannot be cancelled: %s': '流程无权被取消: %s',\n};\n","module.exports = {\n  'en-us': require('./locale/en-us.js'),\n  'zh-cn': require('./locale/zh-cn.js'),\n};\n","module.exports = app => {\n  // const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  const schemas = {};\n  // activityUserTask\n  schemas.activityUserTask = {\n    type: 'object',\n    properties: {\n      assignees: {\n        type: 'object',\n        ebType: 'component',\n        ebTitle: 'Assignees',\n        ebRender: {\n          module: 'a-flowchart',\n          name: 'renderAssignees',\n        },\n        notEmpty: true,\n      },\n      showAssignees: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'Show Assignees',\n      },\n      confirmation: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'Confirmation Assignees',\n      },\n      confirmationAllowAppend: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'ConfirmationAllowAppend',\n      },\n      bidding: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'Bidding',\n      },\n      completionCondition: {\n        type: 'object',\n        ebType: 'json',\n        ebTitle: 'Completion Condition',\n        notEmpty: true,\n      },\n      rejectedNode: {\n        type: 'string',\n        ebType: 'component',\n        ebTitle: 'Rejected Node',\n        ebRender: {\n          module: 'a-flowchart',\n          name: 'renderRejectedNode',\n        },\n      },\n      allowPassTask: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'Allow Pass Task',\n      },\n      allowRejectTask: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'Allow Reject Task',\n      },\n      allowCancelFlow: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'Allow Cancel Flow',\n      },\n      allowRecall: {\n        type: 'boolean',\n        ebType: 'toggle',\n        ebTitle: 'Allow Recall',\n      },\n      schema: {\n        type: 'object',\n        ebType: 'component',\n        ebTitle: 'Field Permissions',\n        ebRender: {\n          module: 'a-flowchart',\n          name: 'renderSchemaFields',\n        },\n        notEmpty: true,\n      },\n    },\n  };\n  return schemas;\n};\n","module.exports = app => {\n  const schemas = {};\n  // startEventAtom\n  schemas.startEventAtom = {\n    type: 'object',\n    properties: {\n      atom: {\n        type: 'object',\n        ebType: 'atomClass',\n        ebTitle: 'Atom Class',\n        notEmpty: true,\n      },\n      conditionExpression: {\n        type: 'string',\n        ebType: 'text',\n        ebTitle: 'Condition Expression',\n        ebTextarea: true,\n      },\n      task: {\n        type: 'object',\n        ebType: 'panel',\n        ebTitle: 'User Task Options',\n        $ref: 'activityUserTask',\n      },\n    },\n  };\n  return schemas;\n};\n","const startEventAtom = require('./schema/startEventAtom.js');\nconst activityUserTask = require('./schema/activityUserTask.js');\n\nmodule.exports = app => {\n  const schemas = {};\n  // startEventAtom\n  Object.assign(schemas, startEventAtom(app));\n  // activityUserTask\n  Object.assign(schemas, activityUserTask(app));\n  // ok\n  return schemas;\n};\n","module.exports = app => {\n\n  class FlowController extends app.Controller {\n\n    async data() {\n      const res = await this.ctx.service.flow.data({\n        flowId: this.ctx.request.body.flowId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return FlowController;\n};\n","module.exports = app => {\n\n  class FlowTaskController extends app.Controller {\n\n    // options\n    //   where, orders, page, history\n    async select() {\n      const options = this.ctx.request.body.options;\n      options.page = this.ctx.bean.util.page(options.page);\n      const items = await this.ctx.service.flowTask.select({\n        options,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.successMore(items, options.page.index, options.page.size);\n    }\n\n    async count() {\n      const options = this.ctx.request.body.options;\n      const count = await this.ctx.service.flowTask.count({\n        options,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(count);\n    }\n\n    async claim() {\n      const res = await this.ctx.service.flowTask.claim({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async complete() {\n      const res = await this.ctx.service.flowTask.complete({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        handle: this.ctx.request.body.handle,\n        formAtom: this.ctx.request.body.formAtom,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async assignees() {\n      const res = await this.ctx.service.flowTask.assignees({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async assigneesConfirmation() {\n      const res = await this.ctx.service.flowTask.assigneesConfirmation({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        handle: this.ctx.request.body.handle,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async recall() {\n      const res = await this.ctx.service.flowTask.recall({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async cancelFlow() {\n      const res = await this.ctx.service.flowTask.cancelFlow({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        handle: this.ctx.request.body.handle,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async actions() {\n      const res = await this.ctx.service.flowTask.actions({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async viewAtom() {\n      const res = await this.ctx.service.flowTask.viewAtom({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async editAtom() {\n      const res = await this.ctx.service.flowTask.editAtom({\n        flowTaskId: this.ctx.request.body.flowTaskId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return FlowTaskController;\n};\n\n","const flow = require('./controller/flow.js');\nconst flowTask = require('./controller/flowTask.js');\n\nmodule.exports = app => {\n  const controllers = {\n    flow,\n    flowTask,\n  };\n  return controllers;\n};\n","const config = require('./config/config.js');\nconst locales = require('./config/locales.js');\nconst errors = require('./config/errors.js');\n\nmodule.exports = app => {\n\n  // aops\n  const aops = require('./aops.js')(app);\n  // beans\n  const beans = require('./beans.js')(app);\n  // routes\n  const routes = require('./routes.js')(app);\n  // controllers\n  const controllers = require('./controllers.js')(app);\n  // services\n  const services = require('./services.js')(app);\n  // models\n  const models = require('./models.js')(app);\n  // meta\n  const meta = require('./meta.js')(app);\n\n  return {\n    aops,\n    beans,\n    routes,\n    controllers,\n    services,\n    models,\n    config,\n    locales,\n    errors,\n    meta,\n  };\n\n};\n","module.exports = app => {\n  const schemas = require('./config/validation/schemas.js')(app);\n  const flowNodes = require('./config/flow/nodes.js')(app);\n  const meta = {\n    base: {\n      atoms: {\n      },\n    },\n    validation: {\n      validators: {\n        // startEventAtom\n        startEventAtom: {\n          schemas: 'startEventAtom,activityUserTask',\n        },\n        // activityUserTask\n        activityUserTask: {\n          schemas: 'activityUserTask',\n        },\n      },\n      keywords: {},\n      schemas,\n    },\n    flow: {\n      nodes: flowNodes,\n    },\n    stats: {\n      providers: {\n        taskClaimings: {\n          user: true,\n          bean: 'taskClaimings',\n        },\n        taskHandlings: {\n          user: true,\n          bean: 'taskHandlings',\n        },\n        taskClaimingsHandlings: {\n          user: true,\n          bean: {\n            module: 'a-stats',\n            name: 'deps',\n          },\n          dependencies: [\n            'a-flowtask:taskClaimings',\n            'a-flowtask:taskHandlings',\n          ],\n        },\n      },\n    },\n  };\n  return meta;\n};\n","module.exports = app => {\n  class FlowNodeStartEventAtomCondition extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aFlowNodeStartEventAtomCondition', options: { disableDeleted: true } });\n    }\n  }\n  return FlowNodeStartEventAtomCondition;\n};\n","module.exports = app => {\n  class FlowTask extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aFlowTask', options: { disableDeleted: true } });\n    }\n  }\n  return FlowTask;\n};\n","module.exports = app => {\n  class FlowTaskHistory extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aFlowTaskHistory', options: { disableDeleted: false } });\n    }\n  }\n  return FlowTaskHistory;\n};\n","const flowNodeStartEventAtomCondition = require('./model/flowNodeStartEventAtomCondition.js');\nconst flowTask = require('./model/flowTask.js');\nconst flowTaskHistory = require('./model/flowTaskHistory.js');\n\nmodule.exports = app => {\n  const models = {\n    flowNodeStartEventAtomCondition,\n    flowTask,\n    flowTaskHistory,\n  };\n  return models;\n};\n","module.exports = app => {\n  const routes = [\n    // flow\n    { method: 'post', path: 'flow/data', controller: 'flow' },\n    // task\n    { method: 'post', path: 'task/select', controller: 'flowTask' },\n    { method: 'post', path: 'task/count', controller: 'flowTask' },\n    { method: 'post', path: 'task/claim', controller: 'flowTask', middlewares: 'transaction' },\n    { method: 'post', path: 'task/complete', controller: 'flowTask', middlewares: 'transaction' },\n    { method: 'post', path: 'task/assignees', controller: 'flowTask' },\n    { method: 'post', path: 'task/assigneesConfirmation', controller: 'flowTask', middlewares: 'transaction' },\n    { method: 'post', path: 'task/recall', controller: 'flowTask', middlewares: 'transaction' },\n    { method: 'post', path: 'task/cancelFlow', controller: 'flowTask', middlewares: 'transaction' },\n    { method: 'post', path: 'task/actions', controller: 'flowTask' },\n    { method: 'post', path: 'task/viewAtom', controller: 'flowTask' },\n    { method: 'post', path: 'task/editAtom', controller: 'flowTask' },\n  ];\n  return routes;\n};\n","module.exports = app => {\n\n  class Flow extends app.Service {\n\n    async data({ flowId, user }) {\n      // flow\n      const flow = await this._data_flow({ flowId, user });\n      if (!flow) return null;\n      // atom\n      const atom = await this._data_atom({ flowId, atomId: flow.flowAtomId });\n      // tasks\n      const tasks = await this._data_tasks({ flowId, user });\n      // ok\n      return { flow, atom, tasks };\n    }\n\n    async _data_flow({ flowId, user }) {\n      // select flow\n      const flow = await this.ctx.bean.flow.get({ flowId, history: true, user });\n      // not throw error\n      // if (!flow) this.ctx.throw(404);\n      // ok\n      return flow;\n    }\n\n    async _data_atom({ flowId, atomId }) {\n      // only read basic info\n      //   a.atomFlowId = {flowId}\n      const atom = await this.ctx.model.queryOne(`\n        select a.*,a.id as atomId,b.module,b.atomClassName from aAtom a\n           left join aAtomClass b on a.atomClassId=b.id\n             where a.deleted=0 and a.iid=? and a.id=?\n                   and a.atomFlowId=?\n        `, [ this.ctx.instance.id, atomId, flowId ]);\n      return atom;\n    }\n\n    async _data_tasks({ flowId, user }) {\n      // select tasks\n      const tasks = await this.ctx.bean.flowTask.select({\n        options: {\n          where: {\n            'a.flowId': flowId,\n            'b.flowNodeType': [ 'startEventAtom', 'activityUserTask' ],\n            __or__: [\n              { 'a.userIdAssignee': user.id },\n              { 'a.flowTaskHidden': 0 },\n            ],\n          },\n          orders: [\n            [ 'a.flowNodeId', 'desc' ],\n            [ 'a.specificFlag', 'desc' ],\n            [ 'a.flowTaskStatus', 'asc' ],\n          ],\n          history: 1,\n        },\n        user: null,\n        pageForce: false,\n      });\n      // loop\n      for (const task of tasks) {\n        // actions\n        if (task.userIdAssignee === user.id && task.flowTaskStatus === 0) {\n          task._actions = await this.ctx.bean.flowTask.actions({ flowTaskId: task.flowTaskId, user });\n        }\n      }\n      return tasks;\n    }\n\n  }\n  return Flow;\n};\n\n","module.exports = app => {\n\n  class FlowTask extends app.Service {\n\n    async select({ options, user }) {\n      return await this.ctx.bean.flowTask.select({ options, user });\n    }\n\n    async count({ options, user }) {\n      return await this.ctx.bean.flowTask.count({ options, user });\n    }\n\n    async claim({ flowTaskId, user }) {\n      return await this.ctx.bean.flowTask.claim({ flowTaskId, user });\n    }\n\n    async complete({ flowTaskId, handle, formAtom, user }) {\n      return await this.ctx.bean.flowTask.complete({ flowTaskId, handle, formAtom, user });\n    }\n\n    async assignees({ flowTaskId, user }) {\n      return await this.ctx.bean.flowTask.assignees({ flowTaskId, user });\n    }\n\n    async assigneesConfirmation({ flowTaskId, handle, user }) {\n      return await this.ctx.bean.flowTask.assigneesConfirmation({ flowTaskId, handle, user });\n    }\n\n    async recall({ flowTaskId, user }) {\n      return await this.ctx.bean.flowTask.recall({ flowTaskId, user });\n    }\n\n    async cancelFlow({ flowTaskId, handle, user }) {\n      return await this.ctx.bean.flowTask.cancelFlow({ flowTaskId, handle, user });\n    }\n\n    async actions({ flowTaskId, user }) {\n      return await this.ctx.bean.flowTask.actions({ flowTaskId, user });\n    }\n\n    async viewAtom({ flowTaskId, user }) {\n      return await this.ctx.bean.flowTask.viewAtom({ flowTaskId, user });\n    }\n\n    async editAtom({ flowTaskId, user }) {\n      return await this.ctx.bean.flowTask.editAtom({ flowTaskId, user });\n    }\n\n  }\n  return FlowTask;\n};\n\n","const flow = require('./service/flow.js');\nconst flowTask = require('./service/flowTask.js');\n\nmodule.exports = app => {\n  const services = {\n    flow,\n    flowTask,\n  };\n  return services;\n};\n","module.exports = require(\"require3\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(421);\n"],"sourceRoot":""}